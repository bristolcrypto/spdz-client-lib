import { Gfp, fromMontgomery } from '../math/Gfp'
import binaryToShare from './binaryToShare'

const range = length => [...Array(length).keys()]

describe('Byte buffers from SPDZ are validated and converted into a share', () => {
  it('rejects if the buffers are not multiple of 48 bytes in length', () => {
    const byteBufferList = [
      Uint8Array.from(range(96)),
      Uint8Array.from(range(97)),
      Uint8Array.from(range(96))
    ]
    const testShouldThrow = () => binaryToShare(byteBufferList)

    expect(testShouldThrow).toThrowError(
      'Spdz proxy 1 provided triple with 97 bytes, must be a multiple of 48.'
    )
  })

  it('rejects if the buffers are not the same multiple of 48 bytes in length', () => {
    const byteBufferList = [
      Uint8Array.from(range(96)),
      Uint8Array.from(range(48)),
      Uint8Array.from(range(96))
    ]
    const testShouldThrow = () => binaryToShare(byteBufferList)

    expect(testShouldThrow).toThrowError(
      'Shares from each proxy are expected to be the same byte length.'
    )
  })

  it('rejects if the triple relation a*b=c is not correct', () => {
    const byteBufferList = [
      Uint8Array.from(range(96)),
      Uint8Array.from(range(96)),
      Uint8Array.from(range(96))
    ]
    const testShouldThrow = () => binaryToShare(byteBufferList)

    expect(testShouldThrow).toThrowError(
      'Triple to be used for a share failed check.'
    )
  })

  it('should accept triples from 2 spdz proxies using triple examples generated by spdz', () => {
    //See https://github.com/bristolcrypto/SPDZ/blob/privateclient/check-triple-shares.cpp
    // Here shares 123, 456, 56088 are split between 2 parties.
    // prettier-ignore
    const a1 = Uint8Array.of(0xe2,0xe8,0x5b,0xb7,0x4a,0x31,0xe7,0xae,0x32,0x06,0x0a,0x88,0xa8,0x8b,0xbd,0x27)
    // prettier-ignore
    const b1 = Uint8Array.of(0x90,0xf0,0x36,0xe0,0xf0,0xf8,0xdc,0x42,0x93,0xe9,0x51,0x57,0x7d,0xe4,0x1b,0x3d)
    // prettier-ignore
    const c1 = Uint8Array.of(0x7f,0x6f,0x2c,0x76,0x09,0x73,0x17,0x59,0xfe,0x67,0x74,0x4a,0x6e,0x15,0xd8,0x17)
    const byteBuffer1 = new Uint8Array(48)
    byteBuffer1.set(a1, 0)
    byteBuffer1.set(b1, 16)
    byteBuffer1.set(c1, 32)

    // prettier-ignore
    const a2 = Uint8Array.of(0x2c,0x16,0x4e,0x70,0x00,0x38,0xa0,0x26,0x87,0x7b,0xea,0x76,0x41,0xf7,0x72,0x7f)
    // prettier-ignore
    const b2 = Uint8Array.of(0xeb,0x0b,0x7a,0xa1,0xb3,0x2c,0x64,0x01,0x83,0x8d,0xac,0xa2,0x1c,0xf4,0x1c,0x3f)
    // prettier-ignore
    const c2 = Uint8Array.of(0x25,0xdf,0xbd,0xb0,0xc0,0x40,0xd5,0x72,0xa3,0xa4,0x62,0xf8,0x6b,0x46,0xc3,0x70)
    const byteBuffer2 = new Uint8Array(48)
    byteBuffer2.set(a2, 0)
    byteBuffer2.set(b2, 16)
    byteBuffer2.set(c2, 32)

    const byteBufferList = [byteBuffer1, byteBuffer2]

    const shares = binaryToShare(byteBufferList)

    expect(shares.length).toEqual(1)
    expect(fromMontgomery(shares[0].val).toString()).toEqual('123')
  })

  it('should only except array of Uint8Array types', () => {
    const testThrowsNotArray = () => binaryToShare('byteBufferList')

    expect(testThrowsNotArray).toThrowError(
      'binaryToShare requires an Array as input.'
    )

    const testThrowsNotUint8Array = () => binaryToShare(['byteBufferList'])

    expect(testThrowsNotUint8Array).toThrowError(
      'binaryToShare requires an Array of Uint8Array buffers.'
    )
  })
})
