'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sendDataToProxy = exports.consumeDataFromProxy = exports.disconnectProxyFromEngine = exports.checkEngineConnection = exports.connectProxyToEngine = undefined;

var _httpStatusCodes = require('http-status-codes');

var _httpStatusCodes2 = _interopRequireDefault(_httpStatusCodes);

var _NoContentError = require('./NoContentError');

var _NoContentError2 = _interopRequireDefault(_NoContentError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Calls to the SPDZ Proxy REST API.
 * A fetch polyfill is expected to have been included, see README.
 */

/* Supress eslint warnings with following: */

/* global fetch */
var isJson = function isJson(headers) {
  return headers.has('Content-Type') && headers.get('Content-Type').startsWith('application/json');
};

/**
 * Extract out body into a json object if it is JSON. 
 * Unsure because errors return a JSON body with (status, message, stack (in dev)).
 * Return json and response.
 */
var parseIfJson = function parseIfJson(response) {
  if (isJson(response.headers)) {
    return response.json().then(function (json) {
      return {
        response: response,
        jsonData: json
      };
    });
  } else {
    return Promise.resolve({
      response: response,
      jsonData: undefined
    });
  }
};

var safeReasonMsg = function safeReasonMsg(result) {
  return result.jsonData !== undefined ? result.jsonData.message : 'No SPDZ API reason message.';
};

/**
 * Connect to a running SPDZ process via the SPDZ Proxy.
 * The clientId is generated by the Proxy if not supplied.
 * @param {String} url Url of proxy server
 * @param {String} apiRoot Root of path e.g. /spdzapi
 * @param {String} clientId optional client Id.
 * @param {String} clientPublicKey optional 64 byte hex string, if set encrypt traffic.
 * @returns Promise resolve(clientId), or reject(err).
 */
var connectProxyToEngine = function connectProxyToEngine(url, apiRoot) {
  var clientId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  var clientPublicKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;

  var bodyData = {};
  if (clientId !== undefined) {
    bodyData.clientId = clientId;
  }
  if (clientPublicKey !== undefined) {
    bodyData.clientPublicKey = clientPublicKey;
  }

  return fetch('' + url + apiRoot + '/connect-to-spdz', {
    method: 'POST',
    headers: {
      'content-type': 'application/json; charset=utf-8'
    },
    body: JSON.stringify(bodyData),
    mode: 'cors'
  }).then(function (response) {
    return parseIfJson(response);
  }).then(function (result) {
    if (result.response.status === _httpStatusCodes2.default.CREATED) {
      var location = result.response.headers.get('Location');
      var matches = location === null ? null : location.match(/.+\/(.+)\/spdz-connection/);
      if (matches === null || matches.length < 2) {
        var error = new Error('Unable to make SPDZ proxy engine connection. Status: ' + result.response.status + '. Reason: Unable to extract clientId from location header ' + location + '.');
        error.reason = {};
        return Promise.reject(error);
      } else {
        return Promise.resolve(matches[1]);
      }
    } else {
      var _error = new Error('Unable to make SPDZ proxy engine connection. Status: ' + result.response.status + '. Reason: ' + safeReasonMsg(result));
      _error.reason = result.jsonData;
      return Promise.reject(_error);
    }
  });
};

/**
 * Check to see if there is a SPDZ proxy to SPDZ engine connection for this client id.
 */
var checkEngineConnection = function checkEngineConnection(host, apiRoot, clientId) {
  return fetch('' + host + apiRoot + '/' + clientId + '/spdz-connection', {
    method: 'GET',
    headers: {
      Accept: 'application/json'
    },
    mode: 'cors'
  }).then(function (response) {
    return parseIfJson(response);
  }).then(function (result) {
    if (result.response.status === _httpStatusCodes2.default.OK) {
      return Promise.resolve();
    } else {
      var error = new Error('SPDZ proxy not connected to SPDZ engine. Status: ' + result.response.status + '. Reason: ' + safeReasonMsg(result));
      error.reason = result.jsonData;
      return Promise.reject(error);
    }
  });
};

/**
 * Success here is a new connection created or already connected.
 */
var disconnectProxyFromEngine = function disconnectProxyFromEngine(host, apiRoot, clientId) {
  return fetch('' + host + apiRoot + '/' + clientId + '/spdz-connection', {
    method: 'DELETE',
    headers: {
      Accept: 'application/json'
    },
    mode: 'cors'
  }).then(parseIfJson).then(function (result) {
    if (result.response.status === _httpStatusCodes2.default.OK) {
      return Promise.resolve(result);
    } else {
      var error = new Error('Unable to disconnect from SPDZ proxy engine. Status: ' + result.response.status + '. Reason: ' + safeReasonMsg(result));
      error.reason = result.jsonData;
      return Promise.reject(error);
    }
  });
};

var consumeDataFromProxy = function consumeDataFromProxy(host, apiRoot, clientId) {
  var waitTimeoutMs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  return fetch('' + host + apiRoot + '/' + clientId + '/consume-data?waitMs=' + waitTimeoutMs, {
    method: 'POST',
    headers: {
      Accept: 'application/octet-stream, application/json'
    },
    mode: 'cors'
  }).then(parseIfJson).then(function (result) {
    if (result.response.status === _httpStatusCodes2.default.OK) {
      // Browsers have arrayBuffer, returns promise which resolves with ArrayBuffer
      // Node polyfill has buffer.
      if (result.response.arrayBuffer) {
        return result.response.arrayBuffer();
      } else {
        return result.response.buffer();
      }
    } else if (result.response.status === _httpStatusCodes2.default.NO_CONTENT) {
      var error = new _NoContentError2.default('No data is available to consume from the SPDZ proxy. Status: ' + result.response.status + '.');
      return Promise.reject(error);
    } else {
      var _error2 = new Error('Unable to consume data from SPDZ proxy. Status: ' + result.response.status + '. Reason: ' + safeReasonMsg(result));
      _error2.reason = result.jsonData;
      return Promise.reject(_error2);
    }
  }).then(function (buffer) {
    return Promise.resolve(new Uint8Array(buffer));
  });
};

/**
 * @param {host} Hostname of spdz proxy
 * @param {apiRoot} api path
 * @param {clientId} used to distinguish which client connection to used
 * @param {payload} JSON array of base64 encoded 16 byte integers
 */
var sendDataToProxy = function sendDataToProxy(host, apiRoot, clientId, payload) {
  return fetch('' + host + apiRoot + '/' + clientId + '/send-data', {
    method: 'POST',
    headers: {
      'content-type': 'application/json; charset=utf-8'
    },
    body: payload,
    mode: 'cors'
  }).then(parseIfJson).then(function (result) {
    if (result.response.status === _httpStatusCodes2.default.OK) {
      return Promise.resolve();
    } else {
      var error = new Error('Unable to send data to SPDZ proxy. Status: ' + result.response.status + '. Reason: ' + safeReasonMsg(result));
      error.reason = result.jsonData;
      return Promise.reject(error);
    }
  });
};

exports.connectProxyToEngine = connectProxyToEngine;
exports.checkEngineConnection = checkEngineConnection;
exports.disconnectProxyFromEngine = disconnectProxyFromEngine;
exports.consumeDataFromProxy = consumeDataFromProxy;
exports.sendDataToProxy = sendDataToProxy;